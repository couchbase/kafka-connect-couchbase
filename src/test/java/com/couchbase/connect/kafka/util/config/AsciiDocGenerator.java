/*
 * Copyright 2020 Couchbase, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.couchbase.connect.kafka.util.config;

import com.couchbase.connect.kafka.config.source.CouchbaseSourceConfig;
import org.apache.kafka.common.config.ConfigDef;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import static org.apache.kafka.common.config.ConfigDef.convertToString;

/**
 * Generates AsciiDoc suitable for inclusion in the source & sink config reference.
 */
public class AsciiDocGenerator {

  public static void main(String[] args) {
//    ConfigDef config = ConfigHelper.define(CouchbaseSinkConfig.class);
    ConfigDef config = ConfigHelper.define(CouchbaseSourceConfig.class);
    System.out.println(":page-partial:");
    System.out.println();
    System.out.println("// This file was automatically generated by " + AsciiDocGenerator.class.getName());
    System.out.println();
    System.out.println(toAsciiDoc(config));
  }

  /**
   * This is a copy & paste of {@link ConfigDef#toEnrichedRst}, modified to
   * output AsciiDoc.
   */
  private static String toAsciiDoc(ConfigDef config) {
    StringBuilder b = new StringBuilder();

    String lastKeyGroupName = "";
    for (ConfigDef.ConfigKey key : sortedConfigs(config)) {
      if (key.internalConfig) {
        continue;
      }
      if (key.group != null) {
        if (!lastKeyGroupName.equalsIgnoreCase(key.group)) {
          b.append("== ").append(key.group).append("\n\n");
        }
        lastKeyGroupName = key.group;
      }

      getConfigKeyDoc(key, b);

      if (key.dependents != null && key.dependents.size() > 0) {
        int j = 0;
        b.append("  * Dependents: ");
        for (String dependent : key.dependents) {
          b.append("`");
          b.append("<<").append(dependent).append(">>");
          if (++j == key.dependents.size())
            b.append("`");
          else
            b.append("`, ");
        }
        b.append("\n");
      }
      b.append("\n");
    }
    return b.toString();

  }

  private static void getConfigKeyDoc(ConfigDef.ConfigKey key, StringBuilder b) {
    b.append("[[").append(key.name).append("]]\n");
    b.append("=== `").append(key.name).append("`").append("\n\n");
    for (String docLine : key.documentation.split("\n")) {
      if (docLine.isEmpty()) {
        continue;
      }
      b.append(docLine.replace(". ", ".\n")).append("\n\n");
    }
    b.append("  * Type: ").append(getConfigValue(key, "Type")).append("\n");
    if (key.hasDefault()) {
      b.append("  * Default: `").append(getConfigValue(key, "Default")).append("`\n");
    }
    if (key.validator != null) {
      b.append("  * Valid Values: ").append(getConfigValue(key, "Valid Values")).append("\n");
    }
    b.append("  * Importance: ").append(getConfigValue(key, "Importance")).append("\n");
  }

  protected static String getConfigValue(ConfigDef.ConfigKey key, String headerName) {
    switch (headerName) {
      case "Name":
        return key.name;
      case "Description":
        return key.documentation;
      case "Type":
        return key.type.toString().toLowerCase(Locale.ROOT);
      case "Default":
        if (key.hasDefault()) {
          if (key.defaultValue == null)
            return "null";
          String defaultValueStr = convertToString(key.defaultValue, key.type);
          if (defaultValueStr.isEmpty())
            return "\"\"";
          else
            return defaultValueStr;
        } else
          return "";
      case "Valid Values":
        return key.validator != null ? key.validator.toString() : "";
      case "Importance":
        return key.importance.toString().toLowerCase(Locale.ROOT);
      default:
        throw new RuntimeException("Can't find value for header '" + headerName + "' in " + key.name);
    }
  }

  private static List<ConfigDef.ConfigKey> sortedConfigs(ConfigDef config) {
    final Map<String, Integer> groupOrd = new HashMap<>();
    int ord = 0;
    for (String group : config.groups()) {
      groupOrd.put(group, ord++);
    }

    List<ConfigDef.ConfigKey> configs = new ArrayList<>(config.configKeys().values());
    configs.sort((k1, k2) -> compare(k1, k2, groupOrd));
    return configs;
  }

  private static int compare(ConfigDef.ConfigKey k1, ConfigDef.ConfigKey k2, Map<String, Integer> groupOrd) {
    int cmp = k1.group == null
        ? (k2.group == null ? 0 : -1)
        : (k2.group == null ? 1 : Integer.compare(groupOrd.get(k1.group), groupOrd.get(k2.group)));
    if (cmp == 0) {
      cmp = Integer.compare(k1.orderInGroup, k2.orderInGroup);
      if (cmp == 0) {
        // first take anything with no default value
        if (!k1.hasDefault() && k2.hasDefault())
          cmp = -1;
        else if (!k2.hasDefault() && k1.hasDefault())
          cmp = 1;
        else {
          cmp = k1.importance.compareTo(k2.importance);
          if (cmp == 0)
            return k1.name.compareTo(k2.name);
        }
      }
    }
    return cmp;
  }
}
